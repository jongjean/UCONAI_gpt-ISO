import React, { useCallback, useEffect, useRef, useState } from "react";
import "./App.css";
import { authLogin, authRegister, AuthTokens, AuthUser } from "./api/auth";
import {
  fetchPendingUsers,
  approveUser as apiApproveUser,
  rejectUser as apiRejectUser,
  deleteUser as apiDeleteUser,
  PendingUser,
} from "./api/admin";

import { fetchModels, requestIsoChat } from "./api/isoChatApi";

import {
  ModelOption,
  RunMode,
  AnswerMode,
  // Message,
  Conversation,
  Guide,
  AttachedFile,
} from "./types/isoChat";

import Sidebar from "./components/Sidebar";
import ChatPanel from "./components/ChatPanel";
import Rightbar from "./components/Rightbar";
import GuidePanel from "./components/GuidePanel";
import {
  fetchGlobalGuides,
  fetchRoomGuides,
  createGuide as apiCreateGuide,
  updateGuide as apiUpdateGuide,
  deleteGuide as apiDeleteGuide,
} from "./api/guides";
import { apiClient } from "./api/client";
import {
  fetchConversations,
  createConversation,
  updateConversation,
  deleteConversation as apiDeleteConversation,
  reorderConversations as apiReorderConversations,
} from "./api/conversations";
import { fetchMessages, createMessage } from "./api/messages";
import {
  presignUpload,
  uploadWithPresignedUrl,
  commitFile,
} from "./api/files";
import { GuideFile } from "./types/isoChat";

const LAST_CONV_KEY = "lastConvId";

// ëª¨ë¸ ì„¤ëª… ë§¤í•‘ (ë¼ë²¨ ë³´ê°•ìš©)
const MODEL_DESCRIPTIONS: Record<string, string> = {
    "gpt-5.2-pro": "ìµœê³ ê¸‰ ì¶”ë¡ Â·ì •í™•ë„ ì¤‘ì‹¬",
    "gpt-5.2": "ìµœì‹  ê· í˜•ì¡íŒ ì„±ëŠ¥",
    "gpt-5.2-chat-latest": "ëŒ€í™” ìµœì í™”",
    "gpt-5.1": "ì•ˆì •ì  ì‘ë‹µ",
};

const normalizeGuideScope = (scope: string | null | undefined): "global" | "conversation" => {
  if (typeof scope !== "string") return "global";
  return scope.toLowerCase() === "conversation" ? "conversation" : "global";
};

const sortGuideFilesAsc = (files: GuideFile[]): GuideFile[] => {
  const toTimestamp = (value?: string) => {
    if (!value) return Number.POSITIVE_INFINITY;
    const parsed = Date.parse(value);
    return Number.isNaN(parsed) ? Number.POSITIVE_INFINITY : parsed;
  };
  return [...files].sort((a, b) => {
    const diff = toTimestamp(a.createdAt) - toTimestamp(b.createdAt);
    if (diff !== 0) return diff;
    return (a.fileName || "").localeCompare(b.fileName || "");
  });
};

const normalizeGuideFile = (file: any): GuideFile => {
  if (!file) {
    return {
      id: `gf-${Date.now()}-${Math.random().toString(36).slice(2)}`,
      fileName: "",
      fileSize: null,
      storageKey: undefined,
      mimeType: undefined,
      downloadUrl: undefined,
    };
  }
  return {
    id: file.id ?? `gf-${Date.now()}-${Math.random().toString(36).slice(2)}`,
    fileName: file.fileName ?? "",
    fileSize:
      typeof file.fileSize === "number"
        ? file.fileSize
        : file.fileSize != null
          ? Number(file.fileSize)
          : null,
    mimeType: file.mimeType ?? undefined,
    storageKey: file.storageKey ?? undefined,
    downloadUrl: file.downloadUrl ?? file.url ?? undefined,
    createdAt: file.createdAt ?? file.created_at ?? undefined,
  };
};

const normalizeGuide = (guide: any): Guide => {
  const normalizedScope = normalizeGuideScope(guide?.scope);
  const files = Array.isArray(guide?.files)
    ? guide.files.map((file: any) => normalizeGuideFile(file))
    : [];

  return {
    ...guide,
    scope: normalizedScope,
    conversationId: guide?.conversationId ?? undefined,
    title: guide?.title ?? "",
    content: guide?.content ?? "",
    files,
    createdAt: guide?.createdAt ?? new Date().toISOString(),
    updatedAt: guide?.updatedAt ?? guide?.createdAt ?? new Date().toISOString(),
  };
};

const App: React.FC = () => {
  /* --------------------------------
   * 1. ëª¨ë¸ / ì‹¤í–‰ ëª¨ë“œ ìƒíƒœ
   * -------------------------------- */
  const [model, setModel] = useState<ModelOption>("gpt-5.2-pro");
  const [modelList, setModelList] = useState<{ id: string; label: string }[]>(
    []
  );
  const [runMode, setRunMode] = useState<RunMode>("responses");
  const [answerMode, setAnswerMode] = useState<AnswerMode>("strict");

  useEffect(() => {
    fetchModels()
      .then((models) =>
        setModelList(
          models.map((m) => ({
            ...m,
            label: MODEL_DESCRIPTIONS[m.id]
              ? `${m.id} (${MODEL_DESCRIPTIONS[m.id]})`
              : m.label || m.id,
          }))
        )
      )
      .catch(() => {
        setModelList([
          { id: "gpt-5.2-pro", label: "ğŸ¥‡ GPT-5.2 Pro (ìµœê³ ê¸‰)" },
          { id: "gpt-5.2", label: "ğŸ¥ˆ GPT-5.2 (ìµœì‹ )" },
          { id: "gpt-5.2-chat-latest", label: "ğŸ’¬ GPT-5.2 Chat (ëŒ€í™”)" },
          { id: "gpt-5.1", label: "âš¡ GPT-5.1 (ì•ˆì •)" },

  /* --------------------------------
   * 2. ëŒ€í™”ë°© / ë©”ì‹œì§€ ìƒíƒœ
   * -------------------------------- */
  const [conversations, setConversations] = useState<Conversation[]>([]);

  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);


  // ì¸ì¦ ìƒíƒœ
  const [authUser, setAuthUser] = useState<AuthUser | null>(() => {
    const saved = localStorage.getItem("authUser");
    return saved ? JSON.parse(saved) : null;
  });
  const [authTokens, setAuthTokens] = useState<AuthTokens | null>(() => {
    const saved = localStorage.getItem("authTokens");
    return saved ? JSON.parse(saved) : null;
  });
  const [pendingUsers, setPendingUsers] = useState<PendingUser[]>([]);
  const [pendingLoading, setPendingLoading] = useState(false);
  const [pendingError, setPendingError] = useState<string | null>(null);
  const [pendingActionIds, setPendingActionIds] = useState<string[]>([]);
  const [pendingUiState, setPendingUiState] = useState<Record<string, "default" | "approved" | "hold">>({});
  const isSuperAdmin = authUser?.role === "SUPER_ADMIN";

  // ì¸ì¦ ì •ë³´ ë¡œì»¬ ì €ì¥
  useEffect(() => {
    if (authUser) {
      localStorage.setItem("authUser", JSON.stringify(authUser));
    } else {
      localStorage.removeItem("authUser");
    }
  }, [authUser]);

  useEffect(() => {
    if (authTokens) {
      localStorage.setItem("authTokens", JSON.stringify(authTokens));
    } else {
      localStorage.removeItem("authTokens");
    }
    // axios ê¸°ë³¸ Authorization í—¤ë” ì„¤ì •/í•´ì œ
    if (authTokens?.access) {
      apiClient.defaults.headers.common["Authorization"] =
        `Bearer ${authTokens.access}`;
      try {
        const payload = JSON.parse(atob(authTokens.access.split(".")[1] || ""));
        setAuthUser((prev) => ({
          id: payload.uid || prev?.id || "",
          email: payload.email || prev?.email || "",
          role: payload.role || prev?.role,
          status: prev?.status,
          totpEnabled: prev?.totpEnabled,
        }));
      } catch (decodeError) {
        console.warn("Unable to decode access token", decodeError);
      }
    } else {
      delete apiClient.defaults.headers.common["Authorization"];
    }
  }, [authTokens]);

  const loadPendingUsers = useCallback(async () => {
    if (!authTokens?.access || !isSuperAdmin) {
      setPendingUsers([]);
      setPendingUiState({});
      return;
    }
    setPendingLoading(true);
    setPendingError(null);
    try {
      const list = await fetchPendingUsers(authTokens.access);
      const sorted = [...list].sort((a, b) => {
        const aSuper = a.role === "SUPER_ADMIN";
        const bSuper = b.role === "SUPER_ADMIN";
        if (aSuper && !bSuper) return -1;
        if (!aSuper && bSuper) return 1;
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      });
      setPendingUsers(sorted);
      setPendingUiState((prev) => {
        const next: Record<string, "default" | "approved" | "hold"> = {};
        sorted.forEach((user) => {
          const prevState = prev[user.id];
          if (prevState === "approved") {
            next[user.id] = "approved";
            return;
          }
          if (user.status === "REJECTED") {
            next[user.id] = "hold";
            return;
          }
          next[user.id] = "default";
        });
        return next;
      });
    } catch (e: any) {
      setPendingError(e?.message || "ìŠ¹ì¸ ëŒ€ê¸° ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingLoading(false);
    }
  }, [authTokens?.access, isSuperAdmin]);

  useEffect(() => {
    if (!isSuperAdmin) {
      setPendingUsers([]);
      setPendingError(null);
      setPendingLoading(false);
      setPendingUiState({});
      return;
    }
    loadPendingUsers();
  }, [isSuperAdmin, loadPendingUsers]);

  const togglePendingAction = useCallback((id: string, active: boolean) => {
    setPendingActionIds((prev) => {
      if (active) {
        if (prev.includes(id)) return prev;
        return [...prev, id];
      }
      return prev.filter((item) => item !== id);
    });
  }, []);

  const handleApprovePendingUser = useCallback(
    async (id: string) => {
      if (!authTokens?.access) return;
      togglePendingAction(id, true);
      setPendingError(null);
      try {
        await apiApproveUser(authTokens.access, id);
        setPendingUsers((prev) =>
          prev.map((user) =>
            user.id === id ? { ...user, status: "APPROVED" } : user
          )
        );
        setPendingUiState((prev) => ({ ...prev, [id]: "approved" }));
      } catch (e: any) {
        setPendingError(e?.message || "ì‚¬ìš©ì ìŠ¹ì¸ì„ ì²˜ë¦¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
      } finally {
        togglePendingAction(id, false);
      }
    },
    [authTokens?.access, togglePendingAction]
  );

  const handleHoldPendingUser = useCallback(
    async (id: string) => {
      if (!authTokens?.access) return;
      togglePendingAction(id, true);
      setPendingError(null);
      try {
        await apiRejectUser(authTokens.access, id);
        setPendingUsers((prev) =>
          prev.map((user) =>
            user.id === id ? { ...user, status: "REJECTED" } : user
          )
        );
        setPendingUiState((prev) => ({ ...prev, [id]: "hold" }));
      } catch (e: any) {
        setPendingError(e?.message || "ì‚¬ìš©ì ê±°ë¶€ë¥¼ ì²˜ë¦¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
      } finally {
        togglePendingAction(id, false);
      }
    },
    [authTokens?.access, togglePendingAction]
  );

  const handleDeletePendingUser = useCallback(
    async (id: string) => {
      if (!authTokens?.access) return;
      togglePendingAction(id, true);
      setPendingError(null);
      try {
        await apiDeleteUser(authTokens.access, id);
        setPendingUsers((prev) => prev.filter((user) => user.id !== id));
        setPendingUiState((prev) => {
          const next = { ...prev };
          delete next[id];
          return next;
        });
      } catch (e: any) {
        setPendingError(e?.message || "ì‚¬ìš©ì ì‚­ì œë¥¼ ì²˜ë¦¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
      } finally {
        togglePendingAction(id, false);
      }
    },
    [authTokens?.access, togglePendingAction]
  );
  // ì¸ì¦ ìƒíƒœì— ë”°ë¼ ì„œë²„ì—ì„œ ëŒ€í™” ëª©ë¡ ë¡œë“œ
  useEffect(() => {
    if (!authTokens?.access) {
      setConversations([]);
      setActiveConversationId(null);
      localStorage.removeItem(LAST_CONV_KEY);
      return;
    }
    fetchConversations()
      .then((list) => {
        if (list.length === 0) {
          // ì„œë²„ì— ëŒ€í™”ê°€ ì—†ìœ¼ë©´ í•˜ë‚˜ ìƒì„±
          createConversation("ìƒˆ í…Œë§ˆ")
            .then((c) => {
              setConversations([c]);
              setActiveConversationId(c.id);
              localStorage.setItem(LAST_CONV_KEY, c.id);
            })
            .catch((e) => console.error("create default conversation error:", e));
          return;
        }
        setConversations(list);
        setActiveConversationId((prev) => {
          const saved = localStorage.getItem(LAST_CONV_KEY);
          const fallback =
            (saved && list.find((c) => c.id === saved)?.id) ||
            (prev && list.find((c) => c.id === prev)?.id) ||
            list[0]?.id ||
            null;
          if (fallback) {
            localStorage.setItem(LAST_CONV_KEY, fallback);
          }
          return fallback;
        });
      })
      .catch((e) => console.error("fetchConversations error:", e));
  }, [authTokens?.access]);

  const activeConversation: Conversation | null =
    conversations.find((c) => c.id === activeConversationId) || null;

  const handleNewConversation = () => {
    if (!authTokens?.access) {
      setError("ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.");
      loginEmailRef.current?.focus();
      return;
    }
    createConversation("ìƒˆ í…Œë§ˆ")
      .then((conv) => {
        setConversations((prev) => {
          const next = [conv, ...prev];
          return next;
        });
        setActiveConversationId(conv.id);
        localStorage.setItem(LAST_CONV_KEY, conv.id);
      })
      .catch((e) => {
        setError(e?.message || "í…Œë§ˆ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      });
  };

  const handleDeleteConversation = (id: string) => {
    if (!authTokens?.access) {
      setError("ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.");
      loginEmailRef.current?.focus();
      return;
    }
    apiDeleteConversation(id)
      .then(() => {
        setConversations((prev) => {
          const filtered = prev.filter((c) => c.id !== id);
          if (id === activeConversationId) {
            const nextId = filtered[0]?.id ?? null;
            setActiveConversationId(nextId);
            if (nextId) localStorage.setItem(LAST_CONV_KEY, nextId);
            else localStorage.removeItem(LAST_CONV_KEY);
          }
          return filtered;
        });
      })
      .catch((e) => setError(e?.message || "í…Œë§ˆ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."));
  };

  /* --------------------------------
   * 3. í…Œë§ˆ ì œëª© ì¸ë¼ì¸ ìˆ˜ì •
   * -------------------------------- */
  const [editingConvId, setEditingConvId] = useState<string | null>(null);
  const [editingTitle, setEditingTitle] = useState("");
  const loginEmailRef = useRef<HTMLInputElement | null>(null);

  const handleEditTitleStart = (conv: Conversation) => {
    setEditingConvId(conv.id);
    setEditingTitle(conv.title);
  };

  const handleEditTitleSave = (id: string) => {
    const newTitle = editingTitle.trim();
    if (!newTitle) {
      setEditingConvId(null);
      setEditingTitle("");
      return;
    }
    updateConversation(id, newTitle)
      .then((updated) => {
        setConversations((prev) => {
          const next = prev.map((c: Conversation) =>
            c.id === id
              ? {
                  ...c,
                  title: updated.title,
                }
              : c
          );
          return next;
        });
        setEditingConvId(null);
        setEditingTitle("");
      })
      .catch((e) => setError(e?.message || "í…Œë§ˆ ì œëª© ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."));
  };

  /* --------------------------------
   * 4. ì§€ì¹¨ / ê°€ì´ë“œ ìƒíƒœ
   * -------------------------------- */
  const [globalGuides, setGlobalGuides] = useState<Guide[]>([]);
  const [conversationGuides, setConversationGuides] = useState<
    Record<string, Guide[]>
  >({});
  const [isGuidePanelOpen, setIsGuidePanelOpen] = useState(false);

  const activeConvGuides: Guide[] = activeConversationId
    ? conversationGuides[activeConversationId] || []
    : [];

  // ì§€ì¹¨ ì¬ë¡œë“œ ìœ í‹¸
  const reloadGlobalGuides = () =>
    fetchGlobalGuides()
      .then((guides) => setGlobalGuides(guides.map((g) => normalizeGuide(g))))
      .catch((e) => console.error("reloadGlobalGuides error:", e));

  const reloadRoomGuides = (convId: string) =>
    fetchRoomGuides(convId)
      .then((guides) =>
        setConversationGuides((prev) => ({
          ...prev,
          [convId]: guides.map((g) => normalizeGuide(g)),
        }))
      )
      .catch((e) => console.error("reloadRoomGuides error:", e));

  // ê°€ì´ë“œ íŒ¨ë„ ì—´ë¦¼ ìƒíƒœ ë¡œì»¬ ì €ì¥/ë³µì›
  useEffect(() => {
    const saved = localStorage.getItem("guidePanelOpen");
    if (saved === "true") {
      setIsGuidePanelOpen(true);
    }
  }, []);

  useEffect(() => {
    localStorage.setItem("guidePanelOpen", isGuidePanelOpen ? "true" : "false");
  }, [isGuidePanelOpen]);

  // ì§€ì¹¨ ë¡œë“œ
  useEffect(() => {
    if (!authTokens?.access) {
      setGlobalGuides([]);
      setConversationGuides({});
      return;
    }
    fetchGlobalGuides()
      .then((guides) => setGlobalGuides(guides.map((g) => normalizeGuide(g))))
      .catch((e) => console.error("fetchGlobalGuides error:", e));
  }, [authTokens?.access]);

  useEffect(() => {
    if (!authTokens?.access || !activeConversationId) return;
    // ë©”ì‹œì§€ ë¡œë“œ
    fetchMessages(activeConversationId)
      .then((msgs) =>
        setConversations((prev) =>
          prev.map((c) =>
            c.id === activeConversationId ? { ...c, messages: msgs } : c
          )
        )
      )
      .catch((e) => console.error("fetchMessages error:", e));
    fetchRoomGuides(activeConversationId)
      .then((guides) =>
        setConversationGuides((prev) => ({
          ...prev,
          [activeConversationId]: guides.map((g) => normalizeGuide(g)),
        }))
      )
      .catch((e) => console.error("fetchRoomGuides error:", e));
  }, [authTokens?.access, activeConversationId]);

  const handleCreateGuide = async (scope: "global" | "conversation") => {
    if (!authTokens?.access) {
      setError("ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.");
      loginEmailRef.current?.focus();
      return;
    }
    try {
      const defaultTitle = "ìƒˆ ì§€ì¹¨";
      const defaultContent = "";
      const createdRaw = await apiCreateGuide(scope, {
        title: defaultTitle,
        content: defaultContent,
        conversationId: scope === "conversation" ? activeConversationId || undefined : undefined,
      });
      const created = normalizeGuide(createdRaw);
      if (scope === "global") {
        setGlobalGuides((prev) => [created, ...prev]);
        reloadGlobalGuides();
      } else if (activeConversationId) {
        setConversationGuides((prev) => ({
          ...prev,
          [activeConversationId]: [created, ...(prev[activeConversationId] || [])],
        }));
        reloadRoomGuides(activeConversationId);
      }
    } catch (e: any) {
      setError(e?.message || "ì§€ì¹¨ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  const handleUpdateGuide = async (guide: Guide) => {
    if (!authTokens?.access) {
      setError("ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.");
      loginEmailRef.current?.focus();
      return;
    }
    try {
      const scopeForRequest = normalizeGuideScope(guide.scope);
      // 1) íŒŒì¼ ë©”íƒ€ ì¤€ë¹„: ê¸°ì¡´ íŒŒì¼ + ìƒˆë¡œ ì¶”ê°€ëœ íŒŒì¼ ì—…ë¡œë“œ
      const filesPayload: GuideFile[] = [];
      const files = guide.files || [];
      const conversationIdForGuide =
        scopeForRequest === "conversation"
          ? guide.conversationId || activeConversationId || undefined
          : undefined;
      if (scopeForRequest === "conversation" && !conversationIdForGuide) {
        throw new Error("conversationId is required for conversation guide");
      }

      // ê¸°ì¡´ íŒŒì¼(ì´ë¯¸ storageKey ìˆìŒ)
      for (const f of files) {
        if (f.storageKey) {
          filesPayload.push({
            id: f.id,
            fileName: f.fileName,
            fileSize: f.fileSize ?? null,
            mimeType: f.mimeType,
            storageKey: f.storageKey,
            downloadUrl: f.downloadUrl,
          });
        }
      }

      // ìƒˆ íŒŒì¼ ì—…ë¡œë“œ í›„ commit
      for (const f of files) {
        if (!f.storageKey && f.file) {
          const { uploadUrl, objectKey } = await presignUpload({
            engine: "iso",
            type: "guide",
            ownerId: guide.id,
            filename: f.fileName || f.file?.name || "unnamed",
          });
          await uploadWithPresignedUrl(
            uploadUrl,
            f.file,
            f.file.type || f.mimeType || "application/octet-stream"
          );
          const commitResult = await commitFile({
            engine: "iso",
            type: "guide",
            ownerId: guide.id,
            originalName: f.fileName || f.file.name,
            objectKey,
            mimetype: f.file.type || f.mimeType || null,
            size: f.file.size,
          });
          const committedMeta: any = commitResult?.file ?? commitResult?.attachment ?? null;
          const resolvedStorageKey = committedMeta?.storageKey || objectKey;
          const resolvedFileSize =
            typeof committedMeta?.fileSize === "number"
              ? committedMeta.fileSize
              : committedMeta?.fileSize != null
              ? Number(committedMeta.fileSize)
              : f.file.size;
          const committedFile: GuideFile = {
            id: committedMeta?.id || f.id,
            fileName:
              committedMeta?.fileName || f.fileName || f.file.name,
            fileSize: resolvedFileSize ?? null,
            mimeType:
              committedMeta?.mimeType || f.file.type || f.mimeType || null,
            storageKey: resolvedStorageKey,
            downloadUrl: committedMeta?.downloadUrl,
          };
          filesPayload.push(committedFile);
          f.id = committedFile.id;
          f.fileName = committedFile.fileName;
          f.fileSize = committedFile.fileSize ?? null;
          f.mimeType = committedFile.mimeType ?? undefined;
          f.storageKey = committedFile.storageKey;
          f.downloadUrl = committedFile.downloadUrl;
          f.file = undefined;
        }
      }

      const uniquePayload = filesPayload.reduce<GuideFile[]>((acc, item) => {
        const key = item.storageKey || `${item.fileName || ""}::${item.fileSize ?? ""}`;
        if (key && acc.some((f) => (f.storageKey || `${f.fileName || ""}::${f.fileSize ?? ""}`) === key)) {
          return acc;
        }
        acc.push(item);
        return acc;
      }, []);

      const updatePayload: {
        title: string;
        content: string;
        conversationId?: string;
        files?: GuideFile[];
      } = {
        title: guide.title,
        content: guide.content,
        conversationId: conversationIdForGuide,
      };
      if (uniquePayload.length > 0) {
        updatePayload.files = uniquePayload;
      }

      const updatedRaw = await apiUpdateGuide(scopeForRequest, guide.id, updatePayload);
      const updated = normalizeGuide(updatedRaw);
      if (scopeForRequest === "global") {
        setGlobalGuides((prev) =>
          prev.map((g) => (g.id === updated.id ? updated : g))
        );
        return updated;
      }
      const convId = guide.conversationId;
      if (!convId && !conversationIdForGuide) return updated;
      const targetConvId = convId || conversationIdForGuide;
      setConversationGuides((prev) => {
        const list: Guide[] = targetConvId ? prev[targetConvId] || [] : [];
        const idx = list.findIndex((g) => g.id === updated.id);
        if (idx === -1) {
          return {
            ...prev,
            ...(targetConvId
              ? {
                  [targetConvId]: [updated, ...list],
                }
              : {}),
          };
        }
        return {
          ...prev,
          ...(targetConvId
            ? {
                [targetConvId]: list.map((g) =>
                  g.id === updated.id ? updated : g
                ),
              }
            : {}),
        };
      });
      return updated;
    } catch (e: any) {
      setError(e?.message || "ì§€ì¹¨ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      return;
    }
  };

  const handleDeleteGuide = async (
    id: string,
    scope: "global" | "conversation"
  ) => {
    if (!authTokens?.access) {
      setError("ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.");
      loginEmailRef.current?.focus();
      return;
    }
    try {
      const convId = scope === "conversation" ? activeConversationId : undefined;
      await apiDeleteGuide(scope, id, convId || undefined);
      if (scope === "global") {
        setGlobalGuides((prev) => prev.filter((g: Guide) => g.id !== id));
        reloadGlobalGuides();
      } else if (convId) {
        setConversationGuides((prev) => {
          const list: Guide[] = prev[convId] || [];
          return {
            ...prev,
            [convId]: list.filter((g: Guide) => g.id !== id),
          };
        });
        reloadRoomGuides(convId);
      }
    } catch (e: any) {
      setError(e?.message || "ì§€ì¹¨ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  /* --------------------------------
   * 5. ì²¨ë¶€ íŒŒì¼ ìƒíƒœ
   * -------------------------------- */
  const [attachedFiles, setAttachedFiles] = useState<AttachedFile[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const addFiles = (files: File[]) => {
    if (!authTokens?.access) {
      setError("ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.");
      loginEmailRef.current?.focus();
      return;
    }
    if (!files.length) return;
    setAttachedFiles((prev) => [
      ...prev,
      ...files.map<AttachedFile>((file) => ({
        id: `af-${Date.now()}-${Math.random().toString(36).slice(2)}`,
        name: file.name,
        file,
      })),
    ]);
  };

  const handleDrop = (e: React.DragEvent<HTMLTextAreaElement>) => {
    e.preventDefault();
    addFiles(Array.from(e.dataTransfer.files || []));
  };

  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    addFiles(Array.from(e.target.files || []));

    e.target.value = "";
  };

  const handleRemoveAttachedFile = (id: string) => {
    setAttachedFiles((prev) => prev.filter((f) => f.id !== id));
  };

  // ì¸ì¦ í•¸ë“¤ëŸ¬
  const handleLogin = async (email: string, password: string, otp?: string) => {
    try {
      setAuthStatus("ë¡œê·¸ì¸ ì¤‘...");
      const res = await authLogin(email, password, otp);
      setAuthUser(res.user);
      setAuthTokens(res.tokens);
      setAuthStatus("ë¡œê·¸ì¸ ì™„ë£Œ");
    } catch (e: any) {
      setAuthStatus(e?.message || "ë¡œê·¸ì¸ ì‹¤íŒ¨");
    }
  };

  const handleRegister = async (email: string, password: string) => {
    try {
      setAuthStatus("íšŒì›ê°€ì… ì¤‘...");
      const res = await authRegister(email, password);
      const message =
        res.message || "ê³„ì •ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ê´€ë¦¬ì ìŠ¹ì¸ ëŒ€ê¸° ì¤‘ì…ë‹ˆë‹¤.";
      setAuthStatus(message);
    } catch (e: any) {
      setAuthStatus(e?.message || "íšŒì›ê°€ì… ì‹¤íŒ¨");
    }
  };

  const handleLogout = () => {
    setAuthUser(null);
    setAuthTokens(null);
    setAuthStatus("ë¡œê·¸ì•„ì›ƒë¨");
    localStorage.removeItem(LAST_CONV_KEY);
    setPendingUsers([]);
    setPendingActionIds([]);
    setPendingError(null);
    setPendingLoading(false);
    setPendingUiState({});
  };

  /* --------------------------------
   * 6.5. ìš°ì¸¡ íŒ¨ë„ í‘œì‹œìš© ì²¨ë¶€/ì§€ì¹¨ ìš”ì•½
   * -------------------------------- */
  const selectGuideFilesForPanel = (guides: Guide[]) =>
    sortGuideFilesAsc(guides.flatMap((g) => g.files || [])).map((f) => ({
      id: f.id || f.storageKey || f.fileName,
      fileName: f.fileName || "(íŒŒì¼)",
      downloadUrl: f.downloadUrl,
    }));

  const commonGuideFiles = selectGuideFilesForPanel(globalGuides);

  const roomGuideFiles = selectGuideFilesForPanel(activeConvGuides);

  const messageAttachments = (activeConversation?.messages || [])
    .flatMap((m) => m.attachments || [])
    .map((a) => ({
      id: a.id || a.storageKey || a.fileName,
      fileName: a.fileName || "(íŒŒì¼)",
      downloadUrl: a.downloadUrl,
    }));

  /* --------------------------------
   * 6. ì…ë ¥ / ì „ì†¡ / ì—ëŸ¬ ìƒíƒœ
   * -------------------------------- */
  const [input, setInput] = useState("");
  const [lastSentInput, setLastSentInput] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [authStatus, setAuthStatus] = useState<string | null>(null);

  const handleSubmit = async (
    e?: React.FormEvent,
    forceContent?: string
  ) => {
    if (e) e.preventDefault();
    if (!authTokens?.access) {
      setError("ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.");
      loginEmailRef.current?.focus();
      return;
    }
    if (!activeConversationId) return;

    const trimmed =
      forceContent !== undefined ? forceContent.trim() : input.trim();
    const hasText = trimmed.length > 0;
    if (!hasText && attachedFiles.length === 0) return;
    const messageContent = hasText ? trimmed : "(ì²¨ë¶€ ì „ì†¡)";

    const currentConv = conversations.find((c) => c.id === activeConversationId);
    if (!currentConv) return;

    setLastSentInput(hasText ? trimmed : "");
    setInput("");
    setLoading(true);
    setError(null);

    try {
      // 1) ì„œë²„ì— ì‚¬ìš©ì ë©”ì‹œì§€ ìƒì„± (DBì— ì €ì¥ë˜ì–´ì•¼ ì²¨ë¶€íŒŒì¼ ownerId ì‚¬ìš© ê°€ëŠ¥)
      const createdUserMsg = await createMessage(
        activeConversationId,
        "user",
        messageContent
      );

      // 2) ì²¨ë¶€íŒŒì¼ ì—…ë¡œë“œ + ì»¤ë°‹(ë©”íƒ€ DB ì €ì¥)
      if (attachedFiles.length > 0 && createdUserMsg?.id) {
        for (const f of attachedFiles) {
          const { uploadUrl, objectKey } = await presignUpload({
            engine: "iso",
            type: "message",
            ownerId: createdUserMsg.id,
            filename: f.name,
          });
          await uploadWithPresignedUrl(uploadUrl, f.file, f.file.type);
          await commitFile({
            engine: "iso",
            type: "message",
            ownerId: createdUserMsg.id,
            originalName: f.name,
            objectKey,
            mimetype: f.file.type,
            size: f.file.size,
          });
        }
      }

      setAttachedFiles([]); // ì²¨ë¶€ ì´ˆê¸°í™”

      // 3) ISO ì±— í˜¸ì¶œ (ì„œë²„ì— ì €ì¥ëœ ë©”ì‹œì§€ ë°°ì—´ ì‚¬ìš©)
      // ë©”ì‹œì§€ ëª©ë¡ì€ ì„œë²„ì—ì„œ ìµœì‹ í™”ëœ í›„ assistant ë©”ì‹œì§€ê¹Œì§€ í¬í•¨í•˜ì—¬ ìµœì¢… fetch 1íšŒë§Œ ìˆ˜í–‰
      await createMessage(activeConversationId, "assistant", "pending"); // ì„ì‹œ assistant ë©”ì‹œì§€ ìƒì„±(ì‹¤ì œ ë‹µë³€ì€ ì•„ë˜ì—ì„œ fetch)
      const finalMsgs = await fetchMessages(activeConversationId);

      // ISO ì±— í˜¸ì¶œ
      const payload = {
        message: messageContent,
        model,
        runMode,
        answerMode,
        messages: finalMsgs.map((m) => ({ role: m.role, content: m.content })),
        globalGuides: globalGuides.map((g: Guide) => ({
          id: g.id,
          title: g.title,
          content: g.content,
        })),
        convGuides: activeConvGuides.map((g: Guide) => ({
          id: g.id,
          title: g.title,
          content: g.content,
        })),
        accessToken: authTokens?.access,
      };

      const res = await requestIsoChat(payload);
      const assistantText: string =
        res?.reply?.content || res?.reply || res?.content || "";

      // ì„œë²„ì— ì–´ì‹œìŠ¤í„´íŠ¸ ë©”ì‹œì§€ ì €ì¥(ì‹¤ì œ ë‹µë³€ìœ¼ë¡œ ì—…ë°ì´íŠ¸)
      await createMessage(activeConversationId, "assistant", assistantText && assistantText.trim().length > 0
        ? assistantText
        : "ìœ íš¨í•œ ì •ë³´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¶”ê°€ ê¸°ì´ˆ ì •ë³´ë¥¼ ì œê³µí•´ ì£¼ì‹œë©´ ë” ì •í™•í•œ ë‹µë³€ì„ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.");

      // ìµœì¢… ë©”ì‹œì§€ ëª©ë¡ì„ ë‹¤ì‹œ ë™ê¸°í™”
      const syncedMsgs = await fetchMessages(activeConversationId);
      setConversations((prev) =>
        prev.map((c: Conversation) =>
          c.id === activeConversationId ? { ...c, messages: syncedMsgs } : c
        )
      );
    } catch (err: any) {
      console.error(err);
      let msg =
        err?.message ||
        "ISO Expert ì„œë²„ í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì„œë²„ ë¡œê·¸ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.";
      // JSON ë¬¸ìì—´ì´ë©´ error í•„ë“œë¥¼ ì¶”ì¶œ
      try {
        const parsed = typeof msg === "string" && msg.trim().startsWith("{")
          ? JSON.parse(msg)
          : null;
        if (parsed?.error) msg = parsed.error;
      } catch (e) {
        /* ignore JSON parse errors */
      }

      if (msg.toLowerCase().includes("auth required") || msg.includes("401")) {
        setError("ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.");
        loginEmailRef.current?.focus();
      } else {
        setError(msg);
      }
    } finally {
      setLoading(false);
    }
  };

  /* --------------------------------
   * 7. ë Œë”ë§: ì¡°ë¦½ë§Œ ë‹´ë‹¹
   * -------------------------------- */
  return (
    <div className="iso-app-root">
      {/* ì¢Œì¸¡: í…Œë§ˆ/ëŒ€í™” ë¦¬ìŠ¤íŠ¸ (Sidebar ì»´í¬ë„ŒíŠ¸) */}
      <Sidebar
        conversations={conversations}
        activeConversationId={activeConversationId || ""}
        onNewConversation={handleNewConversation}
        onSelectConversation={(id) => {
          setActiveConversationId(id);
          localStorage.setItem(LAST_CONV_KEY, id);
        }}
        onDeleteConversation={handleDeleteConversation}
        editingConvId={editingConvId}
        editingTitle={editingTitle}
        onEditTitleStart={handleEditTitleStart}
        onEditTitleSave={handleEditTitleSave}
        setEditingTitle={setEditingTitle}
        onOpenGuidePanel={() => setIsGuidePanelOpen(true)}
        setEditingConvId={setEditingConvId}
        isAuthed={!!authTokens?.access}
        onReorderConversations={(from, to) => {
          setConversations((prev) => {
            const arr = [...prev];
            const [removed] = arr.splice(from, 1);
            arr.splice(to, 0, removed);
            void apiReorderConversations(arr.map((c) => c.id));
            return arr;
          });
        }}
      />

      {/* ì¤‘ì•™: ì±„íŒ… íŒ¨ë„ */}
      <ChatPanel
        activeConversation={activeConversation}
        attachedFiles={attachedFiles}
        input={input}
        lastSentInput={lastSentInput}
        loading={loading}
        error={error}
        onChangeInput={setInput}
        onSubmit={handleSubmit}
        onDrop={handleDrop}
        onFilesAdded={addFiles}
        onRemoveAttachedFile={handleRemoveAttachedFile}
        fileInputRef={fileInputRef}
        onFileInputChange={handleFileInputChange}
      />

      {/* ìš°ì¸¡: ì„¤ì •/ìƒíƒœ íŒ¨ë„ */}
      <Rightbar
        model={model}
        setModel={(v) => setModel(v as ModelOption)}
        modelList={modelList}
        runMode={runMode}
        setRunMode={(v) => setRunMode(v as RunMode)}
        answerMode={answerMode}
        setAnswerMode={(v) => setAnswerMode(v as AnswerMode)}
        attachedFiles={attachedFiles}
        activeConversationId={activeConversationId}
        commonGuideFiles={commonGuideFiles}
        roomGuideFiles={roomGuideFiles}
        messageAttachments={messageAttachments}
        onRemoveFile={handleRemoveAttachedFile}
        authUser={authUser}
        authStatus={authStatus}
        onLogin={handleLogin}
        onRegister={handleRegister}
        onLogout={handleLogout}
        loginInputRef={loginEmailRef}
        pendingUsers={pendingUsers}
        pendingLoading={pendingLoading}
        pendingError={pendingError}
        pendingActionIds={pendingActionIds}
        pendingUiState={pendingUiState}
        onReloadPending={loadPendingUsers}
        onApprovePendingUser={handleApprovePendingUser}
        onHoldPendingUser={handleHoldPendingUser}
        onDeletePendingUser={handleDeletePendingUser}
      />

      {/* í”Œë¡œíŒ… ì§€ì¹¨/ê°€ì´ë“œ íŒ¨ë„ (GuidePanel.tsxëŠ” ê¸°ì¡´ ë²„ì „ ìœ ì§€) */}
      <GuidePanel
        isOpen={isGuidePanelOpen}
        onClose={() => setIsGuidePanelOpen(false)}
        globalGuides={globalGuides}
        conversationGuides={activeConvGuides}
        activeConversationId={activeConversationId}
        onCreateGuide={handleCreateGuide}
        onUpdateGuide={handleUpdateGuide}
        onDeleteGuide={handleDeleteGuide}
        onReloadGlobalGuides={reloadGlobalGuides}
        onReloadRoomGuides={(cid) => {
          const targetId = cid || activeConversationId;
          if (targetId) reloadRoomGuides(targetId);
        }}
      />
    </div>
  );
};

export default App;
